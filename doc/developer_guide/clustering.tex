\section{Clustering}
\label{sec:clustering}

Besides desktop applications running on one host, ZVTM can be used to create applications whose 
rendering tasks will be split among nodes on a display cluster.

Distributed rendering works by replicating the state of one or more VirtualSpace instances 
on the cluster. In this chapter, we introduce clustered views, which are practically the only
deviation from a desktop ZVTM application.

Dependency on \cd{zvtm-cluster} is declared as follows:

\begin{SaveVerbatim}{CodeVerb}
<dependency>
  <groupId>fr.inria.zvtm</groupId>
  <artifactId>zvtm-cluster</artifactId>
  <version>0.2.6-SNAPSHOT</version> <!-- or any newer version -->
</dependency>
\end{SaveVerbatim}
\fbox{\BUseVerbatim[boxwidth=0.99\columnwidth]{CodeVerb}}

\subsection{Clustered Views}

Clustered views describe the display cluster geometry, as well as a viewport within that cluster.
Views are organized around blocks (the basic unit of views). Blocks are arranged in a matrix
and numbered column-wise, starting from 0.

\begin{figure}
\centering
 \includegraphics[width=17cm]{images/clustered_view.png}
   \caption{Clustered View Attributes}
   \label{fig:clview}
\end{figure}

\subsection{Building zvtm-cluster}

\subsubsection{Basic build}

The recommended way of obtaining zvtm-cluster is from the SVN trunk. To
check out zvtm-cluster:

\verb! svn co https://zvtm.svn.sourceforge.net/svnroot/zvtm/zvtm-cluster/trunk !

The build process is managed by \href{http://maven.apache.org/}{Maven}.
Assuming a recent version of maven2 is installed on your machine,
executing

\verb! mvn clean package !

at the project root will build the software and

\verb! mvn install !

will install it in your local repository.

\subsubsection{Build options}

It is possible to build a jar containing the library, plus every
dependency. To do so, execute \verb! mvn assembly:assembly !

This will generate \verb!zvtm-cluster-x.y.z-jar-with-dependencies.jar!

\subsubsection{Agile2d pipeline}

zvtm-cluster can use the Agile2d pipeline through zvtm-agile2d. To build
zvtm-cluster with Agile2d support, run

\verb! mvn -Pagile2d package !

The generic slave \verb! Agile2dSlaveApp ! should be used instead of
\verb! SlaveApp !

\subsection{Launching an executable with maven}

\verb! mvn exec:java -Dexec.mainClass="com.example.Main" [-Dexec.args="argument1"] ... !

For instance, you may launch the generic slave with

\verb! mvn exec:java -Dexec.mainClass="fr.inria.zvtm.cluster.SlaveApp" !

You may also try with

\verb! mvn exec:exec -Dexec.executable="java"  -Dexec.args="-Xmx2g -cp %classpath fr.inria.zvtm.cluster.SlaveApp" !

\subsection{Features (supported/unsupported)}

\subsubsection{Supported}

\begin{itemize}
\item
  Most glyphs (however VImage instances should be replaced by
  ClusteredImage instances for speed - VImage is supported but will
  usually be slower)
\item
  Multiple virtual spaces
\item
  Multiple views and cameras
\item
  Animation framework
\end{itemize}
\subsubsection{Unsupported}

\begin{itemize}
\item
  Portals (portal support is planned, for CameraPortal only at first)
\item
  Lenses (due to their implementation, supporting lenses on large
  display would be too memory-heavy)
\item
  VCursor (we are investigating VCursor support, or a suitable
  replacement)
\end{itemize}
\subsection{Porting an application to zvtm-cluster}

Porting an application is done in three steps:

\begin{itemize}
\item
  If you use Maven, declare a dependency to ZVTM-cluster in your pom
  file
\end{itemize}
\begin{verbatim}
 
<dependency>
  <groupId>fr.inria.zvtm</groupId>
  <artifactId>zvtm-cluster</artifactId>
  <version>0.2.6-SNAPSHOT</version>

</dependency>
\end{verbatim}
\begin{itemize}
\item
  At the very beginning of your program, call
  \verb! VirtualSpaceManager.INSTANCE.setMaster() !
\item
  Create one or more ClusteredView instances
\end{itemize}
Examples are located in the directory
\verb! src/main/java/fr/inria/zvtm/cluster/examples ! . Studying the
examples is a good way to get started.

\subsection{API additions to ZVTM}

\begin{itemize}
\item
  VirtualSpaceManager.setMaster()
\item
  VirtualSpaceManager.addClusteredView()
\item
  VirtualSpaceManager.stop()
\item
  ClusterGeometry class
\item
  ClusteredView class
\item
  ClusteredImage class
\item
  ClusteredStroke class
\end{itemize}
\subsection{Exclusions}

XXX not terribly elegant. It may be necessary to declare your dependency
on zvtm-cluster in the following fashion:

\begin{verbatim}
 
<dependency>
   <groupId>fr.inria.zvtm</groupId>

   <artifactId>zvtm-cluster</artifactId>
   <version>0.2.0-SNAPSHOT</version>
   <exclusions>
      <exclusion>
         <groupId>fr.inria.zvtm</groupId> 
         <artifactId>zvtm</artifactId>

      </exclusion>
   </exclusions>
</dependency>
\end{verbatim}
This is because zvtm-cluster depends on zvtm, but is not an add-on.
Rather, it replaces zvtm and augments it with clustering. Since you want
to avoid linking to the non-clustered classes in a clustered project,
you may need to declare this exclusion.

\subsection{About clustered views}

A clustered view extends the concept of a ZVTM view (i.e. a window) to
display wall. A clustered view is divided into blocks. A block is
displayed by a single slave instance.

\subsection{About clustered images}

There are two possibilities for using images: \verb!ClusteredImage! and
the normal zvtm \verb!VImage!. \verb!ClusteredImage! is defined in the
\verb!fr.inria.zvtm.cluster! package. These images are constructed by
providing an URL. When transmitting these images to the slaves, only a
pointer (URL) is passed, and the slave is given the task of obtaining
the actual image (over an http connection, a shared drive, a common
naming scheme\ldots{}).

\verb!VImage! instances are transmitted fully to the slaves (i.e. the
bitmap is serialized). This is especially useful for resource images
(icons) or images that cannot be put on a web server / shared drive etc.

\subsection{About strokes}

It is possible to set an arbitrary \verb!Stroke! to draw the borders of
a \verb!Glyph!. \verb!Stroke! being an interface, it cannot be
serialized, and several implementations, such as \verb!BasicStroke!, are
not serializable. We provide a serializable wrapper around
\verb!BasicStroke!: \verb!ClusteredStroke!.

\subsection{About paints}

It is possible to set an arbitrary \verb!Paint! to fill the inside of a
\verb!PRectangle! (and soon any \verb!ClosedShape!?). We support
\verb!GradientPaint!, \verb!RadialGradientPaint! and
\verb!LinearGradientPaint!, plus any \verb!Paint! that is serializable.

\subsection{Deploying on WILD}

See the example script \verb! deploy.sh ! located in
\verb! src/main/resources/scripts !. Deploying a pure-java build of
zvtm-cluster (the default) is as simple as copying your build to the
target machines; using native libraries, however, requires more effort
(the correct objects for the wall machines should be deployed and
referenced from the \verb! java.library.path ! variable).

\subsection{Running Applications}

zvtm-cluster applications are split in two parts:

\begin{itemize}
\item
  a master application (the one that you write)
\item
  a generic slave application \verb!fr.inria.zvtm.cluster.SlaveApp!, one
  instance of which is typically run for each screen of the display
  wall.
\end{itemize}
\textbf{All slave instances should be running before the master
application is launched.}

\subsection{Properties}

These are the system properties currently understood by zvtm-cluster.
Define them in the standard way, i.e. by using \verb! -D ! on the
command line, e.g. \verb! -Dzvtm.cluster.channel_conf="foo.xml" !

\begin{itemize}
\item
  \verb! zvtm.cluster.channel_conf !
\end{itemize}
\textbf{TODO: isolate properties in a package?}

\subsection{Slave client options}

A summary of the options supported by SlaveApp can be displayed by
executing

\verb! java fr.inria.zvtm.cluster.SlaveApp --help !

This summary is reproduced here:

\begin{verbatim}
Usage: SlaveApp [options] where options are:
 -b (--block) N         : view block number (slave index)
 -d (--device-name) VAL : use chosen device (fullscreen only)
 -f (--fullscreen)      : open in full screen mode
 -g (--debug)           : show ZVTM debug information
 -h (--help)            : print this help message and exit
 -n (--app-name) VAL    : application name (should match master program)
 -o                     : enable OpenGL acceleration
 -u (--undecorated)     : remove window decorations (borders)
 -x (--x-offset) N      : window x offset (ignored if fullscreen set)
 -y (--y-offset) N      : window y offset (ignored if fullscreen set)
\end{verbatim}
\textbf{Note about OpenGL acceleration: } for the acceleration to be
enabled, you must define sun.java2d.opengl in addition to passing the
\verb! -o ! option to SlaveApp, i.e.,
\verb! java -Dsun.java2d.opengl=True fr.inria.zvtm.cluster.SlaveApp -o (...)!.
This only works under Linux and Windows (the OGL pipeline is not yet
available for Mac OS X).

\subsection{OpenGL information and troubleshooting}

1. The example \verb! OGLClusterExample.java ! is used to trace the
OpenGL rendering capabilities with zvtm-cluster under Linux. This
example contains paths, simple polygons, text, and image samples and
therefore we can check if opengl calls are made for the drawing
operations associated to each of those graphical entities.

2. On each slave machine, we launch two slave applications through the
script :
\verb!/local_slave_ogl.sh -n OGLClusterExample -u -d :0.0 -b 0!, where
``d'' indicates the screen name id and ``u'' indicates undecorated
windows (since we couldn't get fullscreen working simultaneously on two
screens).

3. In \verb!local_slave_ogl.sh!, when calling the java slaveapp, we must
transmit the arguments \verb!-Dsun.java2d.opengl=True! (enabling trace
of opengl operations) and \verb!-Dsun.java2d.opengl.fbobject=false!
(desactivating the use of FrameBufferObject, otherwise the rendering is
not effectuated)

4. On frontal--1, we launch the script
\verb!./local_master_ogl.sh -bw 2560 -bh 1600 -r 1 -c 2!, where ``bw''
and ``bh'' indicate the dimensions of the window of each slave view).

5. The configuration of the slave machine in which it has been tested:
Ubuntu 9.10, NVIDIA GeForce 8800 GT/PCI/SSE2, OpenGL version 3.0.0,
driver version NVIDIA 185.18.36, GLX version 1.4.

6. Trace messages (we get the same output on both slaveapps):
\\\verb!sun.java2d.loops.FillRect::FillRect(AnyColor, SrcNoEa, AnyInt)!\\\verb!sun.java2d.loops.Blit::Blit(IntRgb, SrcNoEa, IntRgb)!\\\verb!sun.java2d.loops.DrawRect::DrawRect(AnyColor, SrcNoEa, AnyInt)!\\\verb!sun.java2d.loops.FillRect::FillRect(AnyColor, SrcNoEa, AnyInt)!\\\verb!sun.java2d.loops.DrawRect::DrawRect(AnyColor, SrcNoEa, AnyInt)!\\\verb!sun.java2d.loops.FillPath::FillPath(AnyColor, SrcNoEa, AnyInt)!\\\verb!sun.java2d.loops.DrawPath::DrawPath(AnyColor, SrcNoEa, AnyInt)!\\\verb!sun.java2d.loops.DrawGlyphList::DrawGlyphList(AnyColor, SrcNoEa, AnyInt)!\\\verb!sun.java2d.opengl.OGLSwToSurfaceBlit::Blit(IntRgb, AnyAlpha, "OpenGL Surface")!\\\verb!sun.java2d.opengl.OGLSurfaceToSurfaceBlit::Blit("OpenGL Surface", AnyAlpha, "OpenGL Surface")!\\

7. On WILD slaves (as of Feb 2011), the argument
\verb!-Dsun.java2d.opengl.fbobject=true! works and the last line of the
above trace output
becomes:\\\verb!sun.java2d.opengl.OGLRTTSurfaceToSurfaceBlit::Blit("OpenGL Surface (render-to-texture)", AnyAlpha, "OpenGL Surface")!\\

\subsection{Graceful shutdown}

The method \verb! VirtualSpaceManager.stop() ! has been added to try to
initiate an orderly shutdown of the whole cluster.

\subsection{Logging: configuring log4j}

Since we do not want to force a particular logging library on
zvtm-cluster users, logging is done through
\href{http://www.slf4j.org/}{slf4j}. At the moment, we use the log4j
back-end to actually perform the work. A sample properties file
\verb!log4j.properties! is provided with zvtm-cluster. Modify it to suit
your purposes. \textbf{This properties file should be in your
classpath.}

\subsection{Quirks and troubleshooting}

\begin{itemize}
\item
  When launching an application, the slave views do not display anything
\end{itemize}
Check the application name property: the cluster name for your
application and the generic slaves should match. That is, if you called

\verb! VirtualSpaceManager.INSTANCE.setMaster("FooApp") !

in your application, you should start the generic slaves using

\verb! java fr.inria.zvtm.cluster.SlaveApp -n FooApp !

(classpath and other options omitted).

\begin{itemize}
\item
  \verb!DPath! clustering is only available when using java 1.6+. This
  is because \verb!GeneralPath! was not serializable before java 1.6.
\end{itemize}
\subsection{Choosing the right garbage collector}

It is advisable to use the concurrent mark and sweep garbage collector,
which will minimize pause times. To do so, pass the option
\verb!-XX:+UseConcMarkSweepGC! when running both the master and slave
apps.

There is a
\href{http://www.oracle.com/technetwork/java/gc-tuning-5-138395.html}{nice
article} on tuning garbage collection using the Oracle JVM.

\subsection{Generic Java troubleshooting links and tips:}

\href{http://java.sun.com/javase/6/webnotes/trouble/other/matrix6-Unix.html}{Java
6 quick troubleshooting tips}

\href{http://java.sun.com/developer/technicalArticles/Programming/HPROF.html}{hprof}

Discover hprof options by running:

\begin{verbatim}
java -Xrunhprof:help
\end{verbatim}
Start VM with \verb!-XX:+HeapDumpOnOutOfMemoryError!; if
OutOfMemoryError is thrown, VM generates a heap dump.

\subsection{Developer tips/best practices}

\subsubsection{Branches}

When creating a branch (for example a throwaway branch for a demo),
rename it (change the artifact id in the maven project file). This way,
you will avoid deploying the wrong code by mistake. Of course, if the
branch is a feature branch that you intend to merge back into the trunk,
change back the artifact id when merging.

\subsubsection{Version numbers}

We are still at 0.something. When moving to 1.0 it may be useful to
adopt \href{http://semver.org/}{semantic versioning}.

\subsection{Instrumenting zvtm-cluster for performance measurement}

\subsubsection{Running with YourKit Java Profiler}

\href{http://www.yourkit.com}{YJP} is a commercial java profiler.
In-Situ owns a licence for this software.
\href{http://www.yourkit.com/docs/80/help/agent.jsp}{Here} are the
instructions needed to run programs under YJP. It mostly boils down to
running

\begin{verbatim}
java -agentlib:yjpagent FooClass
\end{verbatim}
after the yjp agent library directory has been added to your
\verb!LD_LIBRARY_PATH!. One interesting feature of YJP is that it allows
profiling of remote applications. Connecting to a remote application is
described \href{http://www.yourkit.com/docs/80/help/connect.jsp}{here}.

\subsubsection{Running with VisualVM}

\href{https://visualvm.dev.java.net/}{VisualVM} allows monitoring of the
Java virtual machine that runs an application (heap size, occupancy,
thread states, \ldots{}) as well as basic CPU and memory profiling. To
install VisualVM under Debian, run

\verb!apt-get install visualvm !

Then run VisualVM with

\verb! jvisualvm !

VisualVM allows monitoring remote applications using jstatd, but not
remote profiling. This is described
\href{https://visualvm.dev.java.net/gettingstarted.html}{here}.

\subsection{Network monitoring with JMX and JGroups}

\href{http://community.jboss.org/wiki/JMX}{JMX support for JGroups}

\subsection{Resources}

\href{http://zvtm.sf.net}{ZVTM website (sourceforge)}. Before using
zvtm-cluster, you should have basic familiarity with ZVTM.

\href{http://insitu.lri.fr/WILD/ZVTMCluster}{zvtm-cluster} presentation
page on this wiki.

\href{http://community.jboss.org/wiki/JGroups}{JGroups wiki}

\subsection{ToDo List}

\begin{itemize}
\item
  portal support
\item
  picking and VCursor support
\item
  better dependency handling (maven)
\item
  change cluster geometry dynamically
\end{itemize}
\subsection{Glossary}

\subsubsection{Block}

The part of a clustered view that can be displayed by a single machine
(typically the area covered by one or two screens).

\subsubsection{Camera}

A Camera is a zvtm concept. A Camera has a position in 3d space, but
always looks straight down. Camera creation and movements are propagated
to slaves, but with an offset applied to match the slave's position
within the wall.

\subsubsection{Cluster Geometry}

Describes a display wall. The most important pieces of information
contained in a ClusterGeometry are the number of screens (rows and
columns) and the size of each screen (in pixels).

\subsubsection{Clustered View}

A clustered view extends the concept of a ZVTM view (i.e. a window) to
display wall. A clustered view is divided into blocks. A block is
displayed by a single slave instance.

\subsubsection{Delta}

A Delta represents a change from an application value (state) to the
next. Examples of Deltas are: creating a camera, creating a virtual
space, adding a glyph to a virtual space, changing a glyph's border
color\ldots{}

\subsubsection{Glyph}

Graphical object. Examples of glyphs are an image, a rectangle, a
circle, a path. Glyphs can be manipulated in a homogeneous fashion (i.e.
resize() resizes a Circle or an image, moveTo() moves any glyph\ldots{})

\subsubsection{Identifiable}

An Identifiable is an object that may be replicated across the cluster.

\subsubsection{Master}

A Master is a (bespoke) ZVTM application which declares itself as a
master. By doing so, it broadcasts changes to its state to all machines
on the cluster.

\subsubsection{Slave}

A Slave is a generic display application that displays part of a
clustered view. A Slave is identified by its block id.

\subsubsection{Virtual Space}

An infinite plane on which Glyphs are laid. An arbitrary number of
virtual spaces can be observed in a View (through the use of Cameras).

